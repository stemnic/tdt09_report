\section{Discussion}
\label{discussion}

When it comes to implementation of a hypervisor we looked at multiple candidates that might for fill the requirements that we want our hypervisor to deliver. RVirt\footnote{ \href{https://github.com/mit-pdos/RVirt}{Link to RVirt github}} was a hypervisor that we looked into that might have promise to todo what we want, although there was not enough time to investigate it thoroughly. Although we are uncertain if these hypervisor should actually support the use of hypercalls (syscalls) and software generated interrupts as we use in the implementation stage. From our understanding many of the hypervisor projects that exists are fairly new or not as matured for the riscv platform compered to the more traditional x86 or arm architectures. Also the writer of this report has yet to have some practical experience working with a hypervisor programmatically so you would need todo your own research before choosing a hypervisor.

There might be alternative ways of implementing the putc function in \ref{imp:console-write} rather than using syscalls though it appeared to be the more appropriate choice for communicating with the hypervisor. Uses of signals by through writing to a shared memory between the hypervisor and the xv6 operating system could also be a way of implementing it. Though that would be relying on the hypervisor doing regular check of these bits and shared memory often enough so the output buffers don’t become full. 

Regarding the user input section or console read part of the implementation \ref{imp:console-read} again a software emulated interrupt from the hypervisor seemed simplest here, especially since it require so little change of the original xv6 code base and converts well one wishes to convert more of the xv6 interrupt expecting handlers to be compatible with a paravirtualization. This might though not be the most efficient way of doing it since it requires the hypervisor to emulate the interrupt to make xv6 think it just got a regular interrupt. Though we are having a hard time coming up with a alternative solution that would not require some sort of polling (checking regularly for changes in a buffer or register) on the guest side which would generate significantly more latency. But since the writer is fairly new to this field there might exist alternative solutions which are better.

Since UART was the only interface discussed in the implementation stage it is not known if the suggested methods of syscalls and software emulated interrupts are solutions that will work as a replacement for all of xv6’s hardware interfacing drivers. Though the benefit of already having a hypervisor in the bottom enables us to still use some of the concepts from full virtualization if syscalls are not viable. This is as discussed in the theory section \ref{theory:fullvirtualization} just letting xv6 use the hardware drivers that it already have implemented and than have a trap handler in the hypervisor which knows how to translate these hardware calls. Performance will not be as optimal but the end product will be something that is functional.